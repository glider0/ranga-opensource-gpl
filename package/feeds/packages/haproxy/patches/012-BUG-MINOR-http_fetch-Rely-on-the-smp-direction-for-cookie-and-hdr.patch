commit ef9cafc46c13eea2db65152e452607a6566cbeac
Author: Christopher Faulet <cfaulet@haproxy.com>
Date:   Thu May 16 10:07:30 2019 +0200

    BUG/MINOR: http_fetch: Rely on the smp direction for "cookie()" and "hdr()"
    
    A regression was introduced in the commit 89dc49935 ("BUG/MAJOR: http_fetch: Get
    the channel depending on the keyword used") on the samples "cookie()" and
    "hdr()". Unlike other samples manipulating the HTTP headers, these ones depend
    on the sample direction. To fix the bug, these samples use now their own
    functions. Depending on the sample direction, they call smp_fetch_cookie() and
    smp_fetch_hdr() with the appropriate keyword.
    
    Thanks to Yves Lafon to report this issue.
    
    This patch must be backported wherever the commit 89dc49935 was backported. For
    now, 1.9 and 1.8.
    
    (cherry picked from commit c1f40dd4920050ec5a83b2a5d22a3eb4e4be425a)
    Signed-off-by: Christopher Faulet <cfaulet@haproxy.com>
    (cherry picked from commit 5eaf770abfce56951202cb1ea55a968f5ec8be71)
    Signed-off-by: Christopher Faulet <cfaulet@haproxy.com>

diff --git a/src/proto_http.c b/src/proto_http.c
index 556cabad..32aeef2d 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -10218,6 +10218,17 @@ smp_fetch_hdr(const struct arg *args, struct sample *smp, const char *kw, void *
 	return 0;
 }
 
+/* Same than smp_fetch_hdr() but only relies on the sample direction to choose
+ * the right channel. So instead of duplicating the code, we just change the
+ * keyword and then fallback on smp_fetch_hdr().
+ */
+static int
+smp_fetch_chn_hdr(const struct arg *args, struct sample *smp, const char *kw, void *private)
+{
+	kw = ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ ? "req.hdr" : "res.hdr");
+	return smp_fetch_hdr(args, smp, kw, private);
+}
+
 /* 6. Check on HTTP header count. The number of occurrences is returned.
  * Accepts exactly 1 argument of type string.
  */
@@ -10935,6 +10946,17 @@ int smp_fetch_cookie(const struct arg *args, struct sample *smp, const char *kw,
 	return found;
 }
 
+/* Same than smp_fetch_cookie() but only relies on the sample direction to
+ * choose the right channel. So instead of duplicating the code, we just change
+ * the keyword and then fallback on smp_fetch_cookie().
+ */
+static int
+smp_fetch_chn_cookie(const struct arg *args, struct sample *smp, const char *kw, void *private)
+{
+	kw = ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ ? "req.cook" : "res.cook");
+	return smp_fetch_cookie(args, smp, kw, private);
+}
+
 /* Iterate over all cookies present in a request to count how many occurrences
  * match the name in args and args->data.str.len. If <multi> is non-null, then
  * multiple cookies may be parsed on the same line. The returned sample is of
@@ -12855,7 +12877,7 @@ static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {
 	 * for ACL compatibility only.
 	 */
 	{ "cook",            smp_fetch_cookie,         ARG1(0,STR),      NULL,    SMP_T_STR,  SMP_USE_HRQHV },
-	{ "cookie",          smp_fetch_cookie,         ARG1(0,STR),      NULL,    SMP_T_STR,  SMP_USE_HRQHV|SMP_USE_HRSHV },
+	{ "cookie",          smp_fetch_chn_cookie,     ARG1(0,STR),      NULL,    SMP_T_STR,  SMP_USE_HRQHV|SMP_USE_HRSHV },
 	{ "cook_cnt",        smp_fetch_cookie_cnt,     ARG1(0,STR),      NULL,    SMP_T_SINT, SMP_USE_HRQHV },
 	{ "cook_val",        smp_fetch_cookie_val,     ARG1(0,STR),      NULL,    SMP_T_SINT, SMP_USE_HRQHV },
 
@@ -12863,7 +12885,7 @@ static struct sample_fetch_kw_list sample_fetch_keywords = {ILH, {
 	 * only here to match the ACL's name, are request-only and are used for
 	 * ACL compatibility only.
 	 */
-	{ "hdr",             smp_fetch_hdr,            ARG2(0,STR,SINT), val_hdr, SMP_T_STR,  SMP_USE_HRQHV|SMP_USE_HRSHV },
+	{ "hdr",             smp_fetch_chn_hdr,        ARG2(0,STR,SINT), val_hdr, SMP_T_STR,  SMP_USE_HRQHV|SMP_USE_HRSHV },
 	{ "hdr_cnt",         smp_fetch_hdr_cnt,        ARG1(0,STR),      NULL,    SMP_T_SINT, SMP_USE_HRQHV },
 	{ "hdr_ip",          smp_fetch_hdr_ip,         ARG2(0,STR,SINT), val_hdr, SMP_T_IPV4, SMP_USE_HRQHV },
 	{ "hdr_val",         smp_fetch_hdr_val,        ARG2(0,STR,SINT), val_hdr, SMP_T_SINT, SMP_USE_HRQHV },
