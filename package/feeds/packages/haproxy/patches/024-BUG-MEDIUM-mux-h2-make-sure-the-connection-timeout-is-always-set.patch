commit e7c30a33646f4ec73041ea57bd9fdcdc3e4a80ab
Author: Willy Tarreau <w@1wt.eu>
Date:   Fri Jun 7 08:20:46 2019 +0200

    BUG/MEDIUM: mux-h2: make sure the connection timeout is always set
    
    There seems to be a tricky case in the H2 mux related to stream flow
    control versus buffer a full situation : is a large response cannot
    be entirely sent to the client due to the stream window being too
    small, the stream is paused with the SFCTL flag. Then the upper
    layer stream might get bored and expire this stream. It will then
    shut it down first. But the shutdown operation might fail if the
    mux buffer is full, resulting in the h2s being subscribed to the
    deferred_shut event with the stream *not* added to the send_list
    since it's blocked in SFCTL. In the mean time the upper layer completely
    closes, calling h2_detach(). There we have a send_wait (the pending
    shutw), the stream is marked with SFCTL so we orphan it.
    
    Then if the client finally reads all the data that were clogging the
    buffer, the send_list is run again, but our stream is not there. From
    this point, the connection's stream list is not empty, the mux buffer
    is empty, so the connection's timeout is not set. If the client
    disappears without updating the stream's window, nothing will expire
    the connection.
    
    This patch makes sure we always keep the connection timeout updated.
    There might be finer solutions, such as checking that there are still
    living streams in the connection (i.e. streams not blocked in SFCTL
    state), though this is not necessarily trivial nor useful, since the
    client timeout is the same for the upper level stream and the connection
    anyway.
    
    This patch needs to be backported to 1.9 and 1.8 after some observation.
    
    (cherry picked from commit 7348119fb22bf761c33e06e8a092bd006660cc81)
    Signed-off-by: Christopher Faulet <cfaulet@haproxy.com>
    (cherry picked from commit e76090f78b6b8c519abf20061bfc5a4423816ea5)
    Signed-off-by: Christopher Faulet <cfaulet@haproxy.com>

diff --git a/src/mux_h2.c b/src/mux_h2.c
index b2f3096e..985b9742 100644
--- a/src/mux_h2.c
+++ b/src/mux_h2.c
@@ -2406,12 +2406,8 @@ static int h2_wake(struct connection *conn)
 	}
 
 	if (h2c->task) {
-		if (eb_is_empty(&h2c->streams_by_id) || h2c->mbuf->o) {
-			h2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);
-			task_queue(h2c->task);
-		}
-		else
-			h2c->task->expire = TICK_ETERNITY;
+		h2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);
+		task_queue(h2c->task);
 	}
 	return 0;
 }
@@ -2587,12 +2583,8 @@ static void h2_detach(struct conn_stream *cs)
 		h2_release(h2c->conn);
 	}
 	else if (h2c->task) {
-		if (eb_is_empty(&h2c->streams_by_id) || h2c->mbuf->o) {
-			h2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);
-			task_queue(h2c->task);
-		}
-		else
-			h2c->task->expire = TICK_ETERNITY;
+		h2c->task->expire = tick_add(now_ms, h2c->last_sid < 0 ? h2c->timeout : h2c->shut_timeout);
+		task_queue(h2c->task);
 	}
 }
 
